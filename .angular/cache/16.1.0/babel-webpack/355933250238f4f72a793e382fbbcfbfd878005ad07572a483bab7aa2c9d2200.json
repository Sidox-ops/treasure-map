{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class MapService {\n  constructor() {\n    // Appelons la fonction initializeMap dans le constructeur\n    this.initializeMap(3, 4); // 3: largeur, 4: hauteur\n  }\n\n  initializeFromText(content) {\n    const lines = content.split('\\n');\n    for (let line of lines) {\n      const parts = line.split(' - ');\n      switch (parts[0]) {\n        case 'C':\n          this.createMap(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'M':\n          this.addMountain(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'T':\n          this.addTreasure(parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3]));\n          break;\n        case 'A':\n          this.addAdventurer(parts[1], parseInt(parts[2]), parseInt(parts[3]), parts[4], parts[5]);\n          break;\n      }\n    }\n  }\n  initializeMap(width, height) {\n    this.map = new Array(height).fill(null).map(() => new Array(width).fill('P'));\n    // Ajoutons quelques montagnes et trésors pour tester\n    this.map[1][1] = 'M'; // M pour Montagne\n    this.map[2][2] = 'M'; // Une autre Montagne\n    this.map[0][3] = {\n      type: 'T',\n      treasures: 2\n    }; // T pour Trésor avec 2 trésors\n    this.map[1][3] = {\n      type: 'T',\n      treasures: 1\n    }; // Un autre Trésor avec 1 trésor\n  }\n\n  getMap() {\n    return this.map;\n  }\n}\nMapService.ɵfac = function MapService_Factory(t) {\n  return new (t || MapService)();\n};\nMapService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: MapService,\n  factory: MapService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["MapService","constructor","initializeMap","initializeFromText","content","lines","split","line","parts","createMap","parseInt","addMountain","addTreasure","addAdventurer","width","height","map","Array","fill","type","treasures","getMap","factory","ɵfac","providedIn"],"sources":["/Users/sidox/dev/treasure-map/src/app/map/service/map.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MapService {\n\n  map!: any[][];\n\n  constructor() {\n    // Appelons la fonction initializeMap dans le constructeur\n    this.initializeMap(3, 4); // 3: largeur, 4: hauteur\n  }\n\n  initializeFromText(content: string) {\n    const lines = content.split('\\n');\n    for (let line of lines) {\n      const parts = line.split(' - ');\n\n      switch (parts[0]) {\n        case 'C':\n          this.createMap(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'M':\n          this.addMountain(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'T':\n          this.addTreasure(parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3]));\n          break;\n        case 'A':\n          this.addAdventurer(parts[1], parseInt(parts[2]), parseInt(parts[3]), parts[4], parts[5]);\n          break;\n      }\n    }\n  }\n\n  initializeMap(width: number, height: number) {\n    this.map = new Array(height).fill(null).map(() => new Array(width).fill('P'));\n\n    // Ajoutons quelques montagnes et trésors pour tester\n    this.map[1][1] = 'M'; // M pour Montagne\n    this.map[2][2] = 'M'; // Une autre Montagne\n    this.map[0][3] = { type: 'T', treasures: 2 }; // T pour Trésor avec 2 trésors\n    this.map[1][3] = { type: 'T', treasures: 1 }; // Un autre Trésor avec 1 trésor\n  }\n\n  getMap() {\n    return this.map;\n  }\n}\n"],"mappings":";AAKA,OAAM,MAAOA,UAAU;EAIrBC,YAAA;IACE;IACA,IAAI,CAACC,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAC5B;;EAEAC,kBAAkBA,CAACC,OAAe;IAChC,MAAMC,KAAK,GAAGD,OAAO,CAACE,KAAK,CAAC,IAAI,CAAC;IACjC,KAAK,IAAIC,IAAI,IAAIF,KAAK,EAAE;MACtB,MAAMG,KAAK,GAAGD,IAAI,CAACD,KAAK,CAAC,KAAK,CAAC;MAE/B,QAAQE,KAAK,CAAC,CAAC,CAAC;QACd,KAAK,GAAG;UACN,IAAI,CAACC,SAAS,CAACC,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UACtD;QACF,KAAK,GAAG;UACN,IAAI,CAACG,WAAW,CAACD,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UACxD;QACF,KAAK,GAAG;UACN,IAAI,CAACI,WAAW,CAACF,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UAC5E;QACF,KAAK,GAAG;UACN,IAAI,CAACK,aAAa,CAACL,KAAK,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;UACxF;;;EAGR;EAEAN,aAAaA,CAACY,KAAa,EAAEC,MAAc;IACzC,IAAI,CAACC,GAAG,GAAG,IAAIC,KAAK,CAACF,MAAM,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACF,GAAG,CAAC,MAAM,IAAIC,KAAK,CAACH,KAAK,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC,CAAC;IAE7E;IACA,IAAI,CAACF,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IACtB,IAAI,CAACA,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IACtB,IAAI,CAACA,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;MAAEG,IAAI,EAAE,GAAG;MAAEC,SAAS,EAAE;IAAC,CAAE,CAAC,CAAC;IAC9C,IAAI,CAACJ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;MAAEG,IAAI,EAAE,GAAG;MAAEC,SAAS,EAAE;IAAC,CAAE,CAAC,CAAC;EAChD;;EAEAC,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACL,GAAG;EACjB;;AA3CWhB,UAAU,C;mBAAVA,UAAU;AAAA;AAAVA,UAAU,C;SAAVA,UAAU;EAAAsB,OAAA,EAAVtB,UAAU,CAAAuB,IAAA;EAAAC,UAAA,EAFT;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}