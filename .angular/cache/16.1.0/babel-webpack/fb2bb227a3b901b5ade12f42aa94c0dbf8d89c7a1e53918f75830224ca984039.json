{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class MapService {\n  constructor() {\n    this.mapSubject = new Subject();\n    this.map$ = this.mapSubject.asObservable();\n    this.adventurers = [];\n    // Appelons la fonction initializeMap dans le constructeur\n    this.initializeMap(3, 4); // 3: largeur, 4: hauteur\n  }\n\n  initializeFromText(content) {\n    const lines = content.split('\\n');\n    for (let line of lines) {\n      const parts = line.split(' - ');\n      switch (parts[0]) {\n        case 'C':\n          this.createMap(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'M':\n          this.addMountain(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'T':\n          this.addTreasure(parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3]));\n          break;\n        case 'A':\n          this.addAdventurer(parts[1], parseInt(parts[2]), parseInt(parts[3]), parts[4], parts[5]);\n          break;\n      }\n    }\n  }\n  initializeMap(width, height) {\n    this.map = new Array(height).fill(null).map(() => new Array(width).fill('P'));\n    // Ajoutons quelques montagnes et trésors pour tester\n    this.map[1][1] = 'M'; // M pour Montagne\n    this.map[2][2] = 'M'; // Une autre Montagne\n    this.map[0][3] = {\n      type: 'T',\n      treasures: 2\n    }; // T pour Trésor avec 2 trésors\n    this.map[1][3] = {\n      type: 'T',\n      treasures: 1\n    }; // Un autre Trésor avec 1 trésor\n  }\n\n  getMap() {\n    return this.map;\n  }\n  createMap(width, height) {\n    this.map = new Array(height);\n    for (let i = 0; i < height; i++) {\n      this.map[i] = new Array(width).fill('.');\n    }\n  }\n  addMountain(x, y) {\n    if (this.map[y] && this.map[y][x] !== undefined) {\n      this.map[y][x] = 'M';\n    }\n  }\n  addTreasure(x, y, count) {\n    if (this.map[y] && this.map[y][x] !== undefined) {\n      this.map[y][x] = `T(${count})`;\n    }\n  }\n  addAdventurer(name, x, y, orientation, sequence) {\n    this.adventurers.push({\n      name,\n      x,\n      y,\n      orientation,\n      sequence\n    });\n  }\n}\nMapService.ɵfac = function MapService_Factory(t) {\n  return new (t || MapService)();\n};\nMapService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: MapService,\n  factory: MapService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Subject","MapService","constructor","mapSubject","map$","asObservable","adventurers","initializeMap","initializeFromText","content","lines","split","line","parts","createMap","parseInt","addMountain","addTreasure","addAdventurer","width","height","map","Array","fill","type","treasures","getMap","i","x","y","undefined","count","name","orientation","sequence","push","factory","ɵfac","providedIn"],"sources":["/Users/sidox/dev/treasure-map/src/app/map/service/map.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MapService {\n  private mapSubject = new Subject<any[][]>();\n  map$ = this.mapSubject.asObservable();\n\n  map!: any[][];\n  adventurers: any[] = [];\n\n  constructor() {\n    // Appelons la fonction initializeMap dans le constructeur\n    this.initializeMap(3, 4); // 3: largeur, 4: hauteur\n  }\n\n  initializeFromText(content: string) {\n    const lines = content.split('\\n');\n    for (let line of lines) {\n      const parts = line.split(' - ');\n\n      switch (parts[0]) {\n        case 'C':\n          this.createMap(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'M':\n          this.addMountain(parseInt(parts[1]), parseInt(parts[2]));\n          break;\n        case 'T':\n          this.addTreasure(parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3]));\n          break;\n        case 'A':\n          this.addAdventurer(parts[1], parseInt(parts[2]), parseInt(parts[3]), parts[4], parts[5]);\n          break;\n      }\n    }\n  }\n\n  initializeMap(width: number, height: number) {\n    this.map = new Array(height).fill(null).map(() => new Array(width).fill('P'));\n\n    // Ajoutons quelques montagnes et trésors pour tester\n    this.map[1][1] = 'M'; // M pour Montagne\n    this.map[2][2] = 'M'; // Une autre Montagne\n    this.map[0][3] = { type: 'T', treasures: 2 }; // T pour Trésor avec 2 trésors\n    this.map[1][3] = { type: 'T', treasures: 1 }; // Un autre Trésor avec 1 trésor\n  }\n\n  getMap() {\n    return this.map;\n  }\n\n  createMap(width: number, height: number) {\n    this.map = new Array(height);\n    for (let i = 0; i < height; i++) {\n      this.map[i] = new Array(width).fill('.');\n    }\n  }\n\n  addMountain(x: number, y: number) {\n    if (this.map[y] && this.map[y][x] !== undefined) {\n      this.map[y][x] = 'M';\n    }\n  }\n\n  addTreasure(x: number, y: number, count: number) {\n    if (this.map[y] && this.map[y][x] !== undefined) {\n      this.map[y][x] = `T(${count})`;\n    }\n  }\n\n  addAdventurer(name: string, x: number, y: number, orientation: string, sequence: string) {\n    this.adventurers.push({ name, x, y, orientation, sequence });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}